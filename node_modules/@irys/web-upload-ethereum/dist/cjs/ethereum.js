"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumConfig = void 0;
const tslib_1 = require("tslib");
const bignumber_1 = require("@ethersproject/bignumber");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const base_1 = require("@irys/web-upload/tokens/base");
const web_1 = require("@irys/bundles/web");
const ethereumSigner = web_1.InjectedTypedEthereumSigner;
class EthereumConfig extends base_1.BaseWebToken {
    constructor(config) {
        super(config);
        this.inheritsRPC = true;
        this.base = ['wei', 1e18];
    }
    async getTx(txId) {
        const provider = this.providerInstance;
        const response = await provider.getTransaction(txId);
        if (!response)
            throw new Error("Tx doesn't exist");
        if (!response.to)
            throw new Error(`Unable to resolve transactions ${txId} receiver`);
        return {
            from: response.from,
            to: response.to,
            blockHeight: response.blockNumber
                ? new bignumber_js_1.default(response.blockNumber)
                : undefined,
            amount: new bignumber_js_1.default(response.value.toHexString(), 16),
            pending: response.blockNumber ? false : true,
            confirmed: response.confirmations >= this.minConfirm,
        };
    }
    ownerToAddress(owner) {
        // return (
        //   "0x" +
        //   keccak256(Buffer.from(owner.slice(1)))
        //     .slice(-20)
        //     .toString("hex")
        // );
        // return owner;
        return owner.toString().toLowerCase();
    }
    async sign(data) {
        const signer = await this.getSigner();
        return signer.sign(data);
    }
    getSigner() {
        if (!this.signer) {
            this.signer = new web_1.InjectedTypedEthereumSigner(this.wallet);
        }
        return this.signer;
    }
    async verify(pub, data, signature) {
        return ethereumSigner.verify(pub, data, signature);
    }
    async getCurrentHeight() {
        const provider = this.providerInstance;
        const response = await provider.send('eth_blockNumber', []);
        return new bignumber_js_1.default(response, 16);
    }
    async getFee(amount, to) {
        const provider = this.providerInstance;
        const tx = {
            to,
            from: this.address,
            value: '0x' + new bignumber_js_1.default(amount).toString(16),
        };
        const estimatedGas = await provider.estimateGas(tx);
        const gasPrice = await provider.getGasPrice();
        return new bignumber_js_1.default(estimatedGas.mul(gasPrice).toString());
    }
    async sendTx(data) {
        const signer = this.w3signer;
        const receipt = await signer.sendTransaction(data); // .catch((e) => { console.error(`Sending tx: ${e}`) })
        return receipt ? receipt.hash : undefined;
    }
    async createTx(amount, to, _fee) {
        const amountc = bignumber_1.BigNumber.from(new bignumber_js_1.default(amount).toFixed());
        const signer = this.w3signer;
        const estimatedGas = await signer.estimateGas({
            to,
            from: this.address,
            value: amountc.toHexString(),
        });
        let gasPrice = await signer.getGasPrice();
        if (this.name === 'matic') {
            gasPrice = bignumber_1.BigNumber.from(new bignumber_js_1.default(gasPrice.toString())
                .multipliedBy(10)
                .decimalPlaces(0)
                .toString());
        }
        const txr = await signer.populateTransaction({
            to,
            from: this.address,
            value: amountc.toHexString(),
            gasPrice,
            gasLimit: estimatedGas,
        });
        return { txId: undefined, tx: txr };
    }
    async getPublicKey() {
        return this.address;
    }
    async ready() {
        this.w3signer = await this.wallet.getSigner();
        this._address = (await this.w3signer.getAddress()).toString().toLowerCase();
        await this.getSigner().ready();
        // this.providerInstance = new .JsonRpcProvider(this.providerUrl);
        this.providerInstance = this.wallet;
        await this.providerInstance?._ready?.();
    }
}
exports.EthereumConfig = EthereumConfig;
exports.default = EthereumConfig;
//# sourceMappingURL=ethereum.js.map