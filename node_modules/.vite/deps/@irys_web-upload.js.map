{
  "version": 3,
  "sources": ["../../@irys/web-upload/src/index.ts", "../../@irys/web-upload/src/builder.ts", "../../@irys/web-upload/src/base.ts", "../../@irys/upload-core/src/hack.ts", "../../@irys/web-upload/src/utils.ts", "../../@irys/web-upload/src/upload.ts"],
  "sourcesContent": ["import { Builder } from './builder';\nexport default Builder;\nexport { Builder as WebUploader };\n\nexport type * from './builder';\n", "import { IrysConfig, Network } from '@irys/upload-core';\nimport { WebIrysConfig, WebToken } from './types';\nimport { BaseWebIrys } from './base';\nimport { Irys } from '@irys/upload-core';\n\n/// UNSTABLE\nexport type Adapter = PreAdapter | PostAdapter | BiphaseAdapter;\n\nexport interface BaseAdapter {\n  phase: 'pre' | 'post' | 'both';\n  // custom function run on adapter load\n  // useful for\n  load?: (builder: this) => void;\n}\n\nexport interface PreAdapter extends BaseAdapter {\n  phase: 'pre';\n  adaptTokenPre: (\n    builder: UploadBuilder,\n    tokenConfig: ConstructableWebToken\n  ) => Resolvable<void>;\n}\n\nexport interface PostAdapter extends BaseAdapter {\n  phase: 'post';\n  adaptTokenPost: (\n    builder: UploadBuilder,\n    tokenConfig: WebToken\n  ) => Resolvable<void>;\n}\n\nexport interface BiphaseAdapter extends BaseAdapter {\n  phase: 'both';\n  adaptTokenPre: (\n    builder: UploadBuilder,\n    tokenConfig: ConstructableWebToken\n  ) => Resolvable<void>;\n  adaptTokenPost: (\n    builder: UploadBuilder,\n    tokenConfig: WebToken\n  ) => Resolvable<void>;\n}\n\nexport type Resolvable<T> = T | Promise<T>;\nexport type Constructable<A extends any[], T> = {\n  new (...args: A): T;\n};\nexport type ConstructableWebToken<T extends any[] = [TokenConfigTrimmed]> =\n  Constructable<T, WebToken>;\n\nexport type TokenConfigTrimmed<Wallet = string | object, Opts = any> = {\n  irys: Irys;\n  wallet?: Wallet;\n  providerUrl?: string;\n  opts?: Opts;\n};\n\nexport class UploadBuilder {\n  // public adapters: Adapter[]\n  public preAdapters: (PreAdapter | BiphaseAdapter)[];\n  public postAdapters: (PostAdapter | BiphaseAdapter)[];\n  public token: ConstructableWebToken;\n  protected provider: any;\n  public config: WebIrysConfig & { irysConfig: IrysConfig };\n  public constructed?: WebToken;\n\n  constructor(tokenClass: ConstructableWebToken) {\n    this.preAdapters = [];\n    this.postAdapters = [];\n\n    this.token = tokenClass;\n    this.config = {\n      url: 'mainnet',\n      irysConfig: {},\n      provider: undefined,\n    };\n  }\n\n  public withProvider(provider: any) {\n    this.provider = provider;\n    return this;\n  }\n\n  public mainnet() {\n    this.config.url = 'mainnet';\n    return this;\n  }\n  public devnet() {\n    this.config.url = 'devnet';\n    return this;\n  }\n\n  public withRpc(rpcUrl: string) {\n    this.config.irysConfig.providerUrl = rpcUrl;\n    return this;\n  }\n\n  public withTokenOptions(opts: any) {\n    this.config.irysConfig.tokenOpts = opts;\n    return this;\n  }\n\n  public bundlerUrl(url: URL | string) {\n    this.config.url = new URL(url).toString();\n    return this;\n  }\n\n  public network(network: Network) {\n    this.config.url = network;\n    return this;\n  }\n\n  public withIrysConfig(config: IrysConfig) {\n    this.config.irysConfig = { ...this.config.irysConfig, ...config };\n    return this;\n  }\n\n  /**\n   * Set the HTTP request timeout - useful if you have a slower connection\n   * @param timeout - timeout in milliseconds\n   * @returns this (builder)\n   */\n  public timeout(timeout: number) {\n    this.config.irysConfig.timeout = timeout;\n    return this;\n  }\n\n  public withAdapter(adapter: Adapter) {\n    // this.adapters.push(adapter)\n    if (adapter.phase != 'post') this.preAdapters.push(adapter);\n    if (adapter.phase != 'pre') this.postAdapters.push(adapter);\n    // @ts-expect-error type intersection issues\n    if (adapter.load) adapter.load(this);\n    return this;\n  }\n\n  public async build() {\n    const irys = new BaseWebIrys({\n      url: this.config.url,\n      config: this.config.irysConfig,\n      getTokenConfig: async (irys) => {\n        for (const preAdapter of this.preAdapters) {\n          await preAdapter.adaptTokenPre(this, this.token);\n        }\n        if (!this.provider) throw new Error('Missing required provider');\n        this.constructed = new this.token({\n          irys,\n          wallet: this.provider,\n          providerUrl: this.config.irysConfig.providerUrl,\n          opts: this.config.irysConfig.tokenOpts,\n        });\n        for (const postAdapter of this.postAdapters) {\n          await postAdapter.adaptTokenPost(this, this.constructed);\n        }\n        return this.constructed;\n      },\n    });\n    // TODO: fix this - this is required due to the async callback fn\n    await irys.build({ wallet: this.provider, config: this.config.irysConfig });\n    await irys.ready();\n    return irys;\n  }\n\n  // Promise contract functions, so users can `await` a builder instance to resolve the builder, instead of having to call build().\n  // very cool, thanks Knex.\n  public async then(\n    onFulfilled?:\n      | ((value: BaseWebIrys) => any | PromiseLike<BaseWebIrys>)\n      | undefined\n      | null,\n    onRejected?: (value: Error) => any | PromiseLike<Error> | undefined | null\n  ): Promise<BaseWebIrys | never> {\n    const res = this.build();\n    return res.then(onFulfilled, onRejected);\n  }\n\n  public async catch(\n    onReject?:\n      | ((value: BaseWebIrys) => any | PromiseLike<BaseWebIrys>)\n      | undefined\n      | null\n  ): Promise<null> {\n    return this.then().catch(onReject);\n  }\n\n  public async finally(\n    onFinally?: (() => void) | null | undefined\n  ): Promise<BaseWebIrys | null> {\n    return this.then().finally(onFinally);\n  }\n}\n\nexport const Builder = (tokenClass: ConstructableWebToken): UploadBuilder => {\n  return new UploadBuilder(tokenClass);\n};\n", "import '@irys/upload-core/hack';\nimport {\n  Irys,\n  Utils,\n  Api,\n  Fund,\n  Transaction,\n  Approval,\n  type IrysConfig,\n  type Network,\n} from '@irys/upload-core';\nimport type { WebToken } from './types';\nimport * as bundles from './utils';\nimport { WebUploader } from './upload';\nimport { Resolvable } from './builder';\n\nexport class BaseWebIrys extends Irys {\n  public declare tokenConfig: WebToken;\n  public declare uploader: WebUploader;\n  uploadFolder!: InstanceType<typeof WebUploader>['uploadFolder'];\n  uploadFile!: InstanceType<typeof WebUploader>['uploadFile'];\n  public getTokenConfig!: (irys: BaseWebIrys) => Resolvable<WebToken>;\n\n  // static async build({\n  //   url,\n  //   network,\n  //   wallet,\n  //   config,\n  //   getTokenConfig,\n  // }: {\n  //   network?: Network;\n  //   url?: string;\n  //   wallet?: { rpcUrl?: string; name?: string; provider: object };\n  //   config?: IrysConfig;\n  //   getTokenConfig: (irys: BaseWebIrys) => Resolvable<WebToken>;\n  // }) {\n  //   // @ts-expect-error types\n  //   super({ url, network, arbundles });\n\n  //   this.debug = config?.debug ?? false;\n\n  //   this.api = new Api({\n  //     url: this.url,\n  //     timeout: config?.timeout ?? 100000,\n  //     headers: config?.headers,\n  //   });\n\n  // }\n\n  constructor({\n    url,\n    wallet,\n    config,\n    getTokenConfig,\n  }: {\n    url?: string | Network;\n    wallet?: { rpcUrl?: string; name?: string; provider: object };\n    config?: IrysConfig;\n    getTokenConfig: (irys: BaseWebIrys) => Resolvable<WebToken>;\n  }) {\n    // @ts-expect-error types\n    super({ url, bundles });\n\n    this.debug = config?.debug ?? false;\n\n    this.api = new Api({\n      url: this.url,\n      timeout: config?.timeout ?? 100000,\n      headers: config?.headers,\n    });\n    this.getTokenConfig = getTokenConfig;\n  }\n\n  // todo: redo this part of the API\n  public async build({\n    wallet,\n    config,\n  }: {\n    wallet?: { rpcUrl?: string; name?: string; provider: object };\n    config?: IrysConfig;\n  }) {\n    this.tokenConfig = await this.getTokenConfig(this);\n    if (\n      this.url.host.includes('devnet.irys.xyz') &&\n      !(config?.providerUrl || wallet?.rpcUrl || this?.tokenConfig?.inheritsRPC)\n    )\n      throw new Error(\n        `Using ${this.url.host} requires a dev/testnet RPC to be configured! see https://docs.irys.xyz/build/d/networks#connecting-to-devnet`\n      );\n\n    this.token = this.tokenConfig.name;\n    this.utils = new Utils(this.api, this.token, this.tokenConfig);\n    this.uploader = new WebUploader(this);\n    this.funder = new Fund(this.utils);\n    this.uploader = new WebUploader(this);\n    this.transactions = new Transaction(this);\n    this.approval = new Approval(this);\n    this.address = 'Please run `await Irys.ready()`';\n    this.uploadFolder = this.uploader.uploadFolder.bind(this.uploader);\n    this.uploadFile = this.uploader.uploadFile.bind(this.uploader);\n  }\n}\nexport default BaseWebIrys;\n", "// crypto hack - this is to stop arweave-js's import time(!!!) check for `subtleCrypto` - which occurs if you try to use the root import of this SDK.\nconst hack = (): void => {\n  throw new Error(`Unimplemented`);\n};\n// @ts-expect-error hack\nglobalThis.crypto ??= {};\n// @ts-expect-error hack\nglobalThis.crypto.subtle ??= {};\n// @ts-expect-error hack\nglobalThis.crypto.subtle.generateKey ??= hack;\n// @ts-expect-error hack\nglobalThis.crypto.subtle.importKey ??= hack;\n// @ts-expect-error hack\nglobalThis.crypto.subtle.exportKey ??= hack;\n// @ts-expect-error hack\nglobalThis.crypto.subtle.digest ??= hack;\n// @ts-expect-error hack\nglobalThis.crypto.subtle.sign ??= hack;\n\nexport default hack;\n", "import {\n  createData,\n  DataItem,\n  deepHash,\n  stringToBuffer,\n  getCryptoDriver,\n  bundleAndSignData,\n  Arweave,\n} from '@irys/bundles/web';\nexport {\n  createData,\n  DataItem,\n  deepHash,\n  stringToBuffer,\n  getCryptoDriver,\n  bundleAndSignData,\n  Arweave,\n};\n", "import { Uploader } from '@irys/upload-core';\nimport type {\n  CreateAndUploadOptions,\n  Manifest,\n  UploadOptions,\n  UploadResponse,\n} from '@irys/upload-core';\nimport type { DataItem, JWKInterface, Tag } from '@irys/bundles';\nimport { ArweaveSigner } from '@irys/bundles';\nimport BaseWebIrys from './base';\n\nexport type TaggedFile = File & {\n  tags?: Tag[];\n};\n\nexport class WebUploader extends Uploader {\n  protected irys: BaseWebIrys;\n  constructor(irys: BaseWebIrys) {\n    super(\n      irys.api,\n      irys.utils,\n      irys.token,\n      irys.tokenConfig,\n      irys.IrysTransaction\n    );\n    this.irys = irys;\n  }\n\n  /**\n   * Uploads a tagged file object, automatically adding the content-type tag if it's not present\n   * @param file - File object to upload\n   * @param opts - optional options for the upload / data item creation\n   * @returns\n   */\n  public async uploadFile(\n    file: File,\n    opts?: CreateAndUploadOptions\n  ): Promise<UploadResponse> {\n    const hasContentType = opts?.tags\n      ? opts.tags.some(({ name }) => name.toLowerCase() === 'content-type')\n      : false;\n    const tags = hasContentType\n      ? opts?.tags\n      : [...(opts?.tags ?? []), { name: 'Content-Type', value: file.type }];\n    return this.uploadData(Buffer.from(await file.arrayBuffer()), {\n      tags,\n      ...opts,\n    });\n  }\n\n  /**\n   * Uploads a list of `File` objects & a generated folder manifest as a nested bundle using a temporary signing key.\n   *\n   * @param files list of `File` objects to upload - note: this code determines the paths via the File's `name` property - if it's undefined, it falls back to `webkitRelativePath`\n   * @param {string} [opts.indexFileRelPath] Relative path for the index file, i.e `folder/index.html`\n   * @param {Tag[]} [opts.manifestTags] List of tags to add onto the manifest transaction\n   * @param {JWKInterface} [opts.throwawayKey] Provide your own throwaway JWK to use for signing the items in the bundle\n   * @param {boolean} [opts.separateManifestTx=false] Whether upload the manifest as a separate tx (not in the nested bundle) - note: transactions in a nested bundle are not indexed by bundlr GQL - if you have tags you want to use to find the manifest, set this option to true\n   *\n   * @returns Standard upload response from the bundler node, plus the throwaway key & address, manifest, manifest TxId and the list of generated transactions\n   */\n  public async uploadFolder(\n    files: TaggedFile[],\n    opts?: UploadOptions & {\n      indexFileRelPath?: string;\n      manifestTags?: Tag[];\n      throwawayKey?: JWKInterface;\n      separateManifestTx?: boolean;\n    }\n  ): Promise<\n    UploadResponse & {\n      throwawayKey: JWKInterface;\n      txs: DataItem[];\n      throwawayKeyAddress: string;\n      manifest: Manifest;\n      manifestId: string;\n    }\n  > {\n    const txs: DataItem[] = [];\n    const txMap = new Map();\n    const throwawayKey =\n      opts?.throwawayKey ??\n      (await this.irys.bundles.getCryptoDriver().generateJWK());\n    const ephemeralSigner = new ArweaveSigner(throwawayKey);\n    for (const file of files) {\n      const path = file.name ?? file.webkitRelativePath;\n      const hasContentType = file.tags\n        ? file.tags.some(({ name }) => name.toLowerCase() === 'content-type')\n        : false;\n\n      const tags = hasContentType\n        ? file.tags\n        : [...(file.tags ?? []), { name: 'Content-Type', value: file.type }];\n\n      const tx = this.irys.bundles.createData(\n        Buffer.from(await file.arrayBuffer()),\n        ephemeralSigner,\n        {\n          tags,\n        }\n      );\n      await tx.sign(ephemeralSigner);\n      txs.push(tx);\n      txMap.set(path, tx.id);\n    }\n    // generate manifest, add to bundle\n    const manifest = await this.generateFolder({\n      items: txMap,\n      indexFile: opts?.indexFileRelPath,\n    });\n    const manifestTx = this.irys.bundles.createData(\n      JSON.stringify(manifest),\n      opts?.separateManifestTx\n        ? this.irys.tokenConfig.getSigner()\n        : ephemeralSigner,\n      {\n        tags: [\n          { name: 'Type', value: 'manifest' },\n          { name: 'Content-Type', value: 'application/x.irys-manifest+json' },\n          ...(opts?.manifestTags ?? []),\n        ],\n      }\n    );\n    if (opts?.separateManifestTx === true) {\n      await manifestTx.sign(this.irys.tokenConfig.getSigner());\n      await this.uploadTransaction(manifestTx, { ...opts });\n    } else {\n      await manifestTx.sign(ephemeralSigner);\n      txs.push(manifestTx);\n    }\n    // upload bundle\n    const bundleRes = await this.uploadBundle(txs, { ...opts });\n\n    return {\n      ...bundleRes.data,\n      manifestId: manifestTx.id,\n      manifest,\n      throwawayKey: bundleRes.throwawayKey,\n      throwawayKeyAddress: bundleRes.throwawayKeyAddress,\n      txs: bundleRes.txs,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "irys"]
}
