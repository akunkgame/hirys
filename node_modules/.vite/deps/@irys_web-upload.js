import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  Api,
  Approval,
  Arweave,
  ArweaveSigner,
  DataItem,
  Fund,
  Irys,
  Transaction,
  Uploader,
  Utils,
  bundleAndSignData,
  createData,
  deepHash,
  getCryptoDriver,
  stringToBuffer
} from "./chunk-MZVA24IJ.js";
import "./chunk-UWOFMTFC.js";
import "./chunk-D57Y2HJE.js";
import {
  __export,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-4RDJM6KU.js";

// node_modules/@irys/web-upload/dist/esm/index.js
var import_dist16 = __toESM(require_dist());
var import_dist17 = __toESM(require_dist2());
var import_dist18 = __toESM(require_dist3());

// node_modules/@irys/web-upload/dist/esm/builder.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/@irys/web-upload/dist/esm/base.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);

// node_modules/@irys/upload-core/dist/esm/hack.js
var import_dist = __toESM(require_dist());
var import_dist2 = __toESM(require_dist2());
var import_dist3 = __toESM(require_dist3());
var hack = () => {
  throw new Error(`Unimplemented`);
};
globalThis.crypto ??= {};
globalThis.crypto.subtle ??= {};
globalThis.crypto.subtle.generateKey ??= hack;
globalThis.crypto.subtle.importKey ??= hack;
globalThis.crypto.subtle.exportKey ??= hack;
globalThis.crypto.subtle.digest ??= hack;
globalThis.crypto.subtle.sign ??= hack;

// node_modules/@irys/web-upload/dist/esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  Arweave: () => Arweave,
  DataItem: () => DataItem,
  bundleAndSignData: () => bundleAndSignData,
  createData: () => createData,
  deepHash: () => deepHash,
  getCryptoDriver: () => getCryptoDriver,
  stringToBuffer: () => stringToBuffer
});
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);

// node_modules/@irys/web-upload/dist/esm/upload.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var WebUploader = class extends Uploader {
  irys;
  constructor(irys) {
    super(irys.api, irys.utils, irys.token, irys.tokenConfig, irys.IrysTransaction);
    this.irys = irys;
  }
  /**
   * Uploads a tagged file object, automatically adding the content-type tag if it's not present
   * @param file - File object to upload
   * @param opts - optional options for the upload / data item creation
   * @returns
   */
  async uploadFile(file, opts) {
    const hasContentType = opts?.tags ? opts.tags.some(({ name }) => name.toLowerCase() === "content-type") : false;
    const tags = hasContentType ? opts?.tags : [...opts?.tags ?? [], { name: "Content-Type", value: file.type }];
    return this.uploadData(Buffer.from(await file.arrayBuffer()), {
      tags,
      ...opts
    });
  }
  /**
   * Uploads a list of `File` objects & a generated folder manifest as a nested bundle using a temporary signing key.
   *
   * @param files list of `File` objects to upload - note: this code determines the paths via the File's `name` property - if it's undefined, it falls back to `webkitRelativePath`
   * @param {string} [opts.indexFileRelPath] Relative path for the index file, i.e `folder/index.html`
   * @param {Tag[]} [opts.manifestTags] List of tags to add onto the manifest transaction
   * @param {JWKInterface} [opts.throwawayKey] Provide your own throwaway JWK to use for signing the items in the bundle
   * @param {boolean} [opts.separateManifestTx=false] Whether upload the manifest as a separate tx (not in the nested bundle) - note: transactions in a nested bundle are not indexed by bundlr GQL - if you have tags you want to use to find the manifest, set this option to true
   *
   * @returns Standard upload response from the bundler node, plus the throwaway key & address, manifest, manifest TxId and the list of generated transactions
   */
  async uploadFolder(files, opts) {
    const txs = [];
    const txMap = /* @__PURE__ */ new Map();
    const throwawayKey = opts?.throwawayKey ?? await this.irys.bundles.getCryptoDriver().generateJWK();
    const ephemeralSigner = new ArweaveSigner(throwawayKey);
    for (const file of files) {
      const path = file.name ?? file.webkitRelativePath;
      const hasContentType = file.tags ? file.tags.some(({ name }) => name.toLowerCase() === "content-type") : false;
      const tags = hasContentType ? file.tags : [...file.tags ?? [], { name: "Content-Type", value: file.type }];
      const tx = this.irys.bundles.createData(Buffer.from(await file.arrayBuffer()), ephemeralSigner, {
        tags
      });
      await tx.sign(ephemeralSigner);
      txs.push(tx);
      txMap.set(path, tx.id);
    }
    const manifest = await this.generateFolder({
      items: txMap,
      indexFile: opts?.indexFileRelPath
    });
    const manifestTx = this.irys.bundles.createData(JSON.stringify(manifest), opts?.separateManifestTx ? this.irys.tokenConfig.getSigner() : ephemeralSigner, {
      tags: [
        { name: "Type", value: "manifest" },
        { name: "Content-Type", value: "application/x.irys-manifest+json" },
        ...opts?.manifestTags ?? []
      ]
    });
    if (opts?.separateManifestTx === true) {
      await manifestTx.sign(this.irys.tokenConfig.getSigner());
      await this.uploadTransaction(manifestTx, { ...opts });
    } else {
      await manifestTx.sign(ephemeralSigner);
      txs.push(manifestTx);
    }
    const bundleRes = await this.uploadBundle(txs, { ...opts });
    return {
      ...bundleRes.data,
      manifestId: manifestTx.id,
      manifest,
      throwawayKey: bundleRes.throwawayKey,
      throwawayKeyAddress: bundleRes.throwawayKeyAddress,
      txs: bundleRes.txs
    };
  }
};

// node_modules/@irys/web-upload/dist/esm/base.js
var BaseWebIrys = class extends Irys {
  uploadFolder;
  uploadFile;
  getTokenConfig;
  // static async build({
  //   url,
  //   network,
  //   wallet,
  //   config,
  //   getTokenConfig,
  // }: {
  //   network?: Network;
  //   url?: string;
  //   wallet?: { rpcUrl?: string; name?: string; provider: object };
  //   config?: IrysConfig;
  //   getTokenConfig: (irys: BaseWebIrys) => Resolvable<WebToken>;
  // }) {
  //   // @ts-expect-error types
  //   super({ url, network, arbundles });
  //   this.debug = config?.debug ?? false;
  //   this.api = new Api({
  //     url: this.url,
  //     timeout: config?.timeout ?? 100000,
  //     headers: config?.headers,
  //   });
  // }
  constructor({ url, wallet, config, getTokenConfig }) {
    super({ url, bundles: utils_exports });
    this.debug = config?.debug ?? false;
    this.api = new Api({
      url: this.url,
      timeout: config?.timeout ?? 1e5,
      headers: config?.headers
    });
    this.getTokenConfig = getTokenConfig;
  }
  // todo: redo this part of the API
  async build({ wallet, config }) {
    this.tokenConfig = await this.getTokenConfig(this);
    if (this.url.host.includes("devnet.irys.xyz") && !(config?.providerUrl || wallet?.rpcUrl || this?.tokenConfig?.inheritsRPC))
      throw new Error(`Using ${this.url.host} requires a dev/testnet RPC to be configured! see https://docs.irys.xyz/build/d/networks#connecting-to-devnet`);
    this.token = this.tokenConfig.name;
    this.utils = new Utils(this.api, this.token, this.tokenConfig);
    this.uploader = new WebUploader(this);
    this.funder = new Fund(this.utils);
    this.uploader = new WebUploader(this);
    this.transactions = new Transaction(this);
    this.approval = new Approval(this);
    this.address = "Please run `await Irys.ready()`";
    this.uploadFolder = this.uploader.uploadFolder.bind(this.uploader);
    this.uploadFile = this.uploader.uploadFile.bind(this.uploader);
  }
};

// node_modules/@irys/web-upload/dist/esm/builder.js
var UploadBuilder = class {
  // public adapters: Adapter[]
  preAdapters;
  postAdapters;
  token;
  provider;
  config;
  constructed;
  constructor(tokenClass) {
    this.preAdapters = [];
    this.postAdapters = [];
    this.token = tokenClass;
    this.config = {
      url: "mainnet",
      irysConfig: {},
      provider: void 0
    };
  }
  withProvider(provider) {
    this.provider = provider;
    return this;
  }
  mainnet() {
    this.config.url = "mainnet";
    return this;
  }
  devnet() {
    this.config.url = "devnet";
    return this;
  }
  withRpc(rpcUrl) {
    this.config.irysConfig.providerUrl = rpcUrl;
    return this;
  }
  withTokenOptions(opts) {
    this.config.irysConfig.tokenOpts = opts;
    return this;
  }
  bundlerUrl(url) {
    this.config.url = new URL(url).toString();
    return this;
  }
  network(network) {
    this.config.url = network;
    return this;
  }
  withIrysConfig(config) {
    this.config.irysConfig = { ...this.config.irysConfig, ...config };
    return this;
  }
  /**
   * Set the HTTP request timeout - useful if you have a slower connection
   * @param timeout - timeout in milliseconds
   * @returns this (builder)
   */
  timeout(timeout) {
    this.config.irysConfig.timeout = timeout;
    return this;
  }
  withAdapter(adapter) {
    if (adapter.phase != "post")
      this.preAdapters.push(adapter);
    if (adapter.phase != "pre")
      this.postAdapters.push(adapter);
    if (adapter.load)
      adapter.load(this);
    return this;
  }
  async build() {
    const irys = new BaseWebIrys({
      url: this.config.url,
      config: this.config.irysConfig,
      getTokenConfig: async (irys2) => {
        for (const preAdapter of this.preAdapters) {
          await preAdapter.adaptTokenPre(this, this.token);
        }
        if (!this.provider)
          throw new Error("Missing required provider");
        this.constructed = new this.token({
          irys: irys2,
          wallet: this.provider,
          providerUrl: this.config.irysConfig.providerUrl,
          opts: this.config.irysConfig.tokenOpts
        });
        for (const postAdapter of this.postAdapters) {
          await postAdapter.adaptTokenPost(this, this.constructed);
        }
        return this.constructed;
      }
    });
    await irys.build({ wallet: this.provider, config: this.config.irysConfig });
    await irys.ready();
    return irys;
  }
  // Promise contract functions, so users can `await` a builder instance to resolve the builder, instead of having to call build().
  // very cool, thanks Knex.
  async then(onFulfilled, onRejected) {
    const res = this.build();
    return res.then(onFulfilled, onRejected);
  }
  async catch(onReject) {
    return this.then().catch(onReject);
  }
  async finally(onFinally) {
    return this.then().finally(onFinally);
  }
};
var Builder = (tokenClass) => {
  return new UploadBuilder(tokenClass);
};

// node_modules/@irys/web-upload/dist/esm/index.js
var esm_default = Builder;
export {
  Builder as WebUploader,
  esm_default as default
};
//# sourceMappingURL=@irys_web-upload.js.map
